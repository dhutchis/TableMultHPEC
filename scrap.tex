


Our initial design operated the iterator stack on a full major compaction.
We chose to operate the iterator stack on a scan instead because major compactions experience
a delay on the order of seconds before Accumulo schedules them, slightly bumping latency,
and because opening a BatchWriter inside an iterator at major compaction presents a small chance for deadlock.
Deadlock may occur if the major compaction iterators triggered enough minor compactions 
such that they exhaust every thread in the compaction thread pool.
This leaves open the chance that a major compaction thread would block on a minor compaction thread
in order for the BatchWriter to write entries, while in turn the minor compaction thread blocks on 
the major compaction since major compactions take a higher thread pool priority than minor ones.




In fact, most GraphBLAS primitives can be expressed in terms of SpGEMM.
We can realize SpEWiseX by multiplying the transpose of the first matrix with the second
and using a custom multiplication function that only acts on elements whose row from the first 
matches the column of the second and returns multiplied elements using the row and column of the second;
\todo{Too much detail for intro}
we can realize SpRef when selecting a row or column subset by multiplying on the left or right with an identity matrix
containing those rows or columns;
and we can realize Reduce by multiplying on the left or right %depending on the dimension of interest 
by a dense vector of all ones.
Outside SpGEMM usage ranges from graph search \cite{kepner2011graph} to table joins \cite{cohen2009mad} 



