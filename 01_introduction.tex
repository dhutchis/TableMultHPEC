%!TEX root =SpGEMM_ACCUMULO_HPEC.tex

\section{Introduction}
\label{sIntro}
% 

Accumulo is well-known as a high performance NoSQL database with respect to ingest and scans \cite{sen2013benchmarking}.
The next step past ingesting and scanning is computing---running enrichment, algorithms and analytics.
Advantages of doing computation in a database like Accumulo %, 
%as opposed to YARN or MapReduce directly on HDFS, 
are \emph{selective access}, \emph{data locality} and \emph{infrastructure reuse}.
Accumulo's features as a database enable fast access to data subsets and queries along indexed attributes.
Further, Accumulo sits atop the physical location data is stored and cached, such that computation inside
Accumulo tablet servers occurs local to data storage and avoids unnecessary network transfers,
effectively moving ``compute to data'' in contrast to client-server models that move ``data to compute.''
Computation within Accumulo also reuses its distributed infrastructure, 
such as write-ahead logging, fault-tolerant execution atop Zookeeper and 
horizontal scalability from masters load balancing tablets.
Why not reuse these services already deployed in production clusters that use Accumulo,
rather than install and maintain new distributed systems for computation?

%cite linear algebra on database data?
One family of computation commonly run on database data is linear algebra.
Researchers in the GraphBLAS Forum \cite{x} have identified a set of primitive operations 
that form a basis for linear algebraic algorithms useful for graphs, including 
Sparse General Matrix Multiplication (SpGEMM),  Sparse Element-wise Multiplication (SpEWiseX),
Sparse Reference of a subset (SpRef), Reduction along a dimension (Reduce),
Function application (Apply) and others.
Graphulo is an effort to realize the GraphBLAS primitives 
and enable algorithms in the language of linear algebra server-side on Accumulo \cite{x}.

%I don't want to make something like MapReduce-- Accumulo facilitates a particular kind of computation 
%using iterators.  Not all computation patterns fit into the iterator framework. EXAMPLE
%We shouldn't stuff computation contradictory to the iterator framework into Accumulo, 
%as many have done stretching iterative algorithms into the MapReduce framework.

In this paper we focus on implementing SpGEMM, a core operation at the heart of GraphBLAS.
%SpGEMM is arguably the most challenging GraphBLAS operation
In fact, most GraphBLAS primitives can be expressed in terms of SpGEMM.
We can realize SpEWiseX by multiplying the transpose of the first matrix with the second
and using a custom multiplication function that only acts on elements whose row from the first 
matches the column of the second and returns multiplied elements using the row and column of the second;
\todo{Too much detail for intro}
we can realize SpRef when selecting a row or column subset by multiplying on the left or right with an identity matrix 
containing those rows or columns;
we can realize Reduce by multiplying on the left or right %depending on the dimension of interest 
by a dense vector of all ones.
%backbone of many linear algebraic algorithms.
One can even view graph search \cite{kepner2011graph} and table joins \cite{x} as applications of SpGEMM.

We call our implementation of SpGEMM on Accumulo \textsc{TableMult}, short for multiplication of Accumulo tables.
Accumulo tables have many similarities to sparse matrices, though a more exact analogy is to Associative Arrays 
\cite{kepner2014gabb}.

We are particularly interested in SpGEMM for queued analytics, that is, analytics on a selected table subset.  
Queued analytics allows us to maximally take advantage of Accumulo as a database 
by quickly accessing a subset of interest, 
whereas whole-table analytics usually perform better on parallel file systems such as Lustre or Hadoop.
We therefore prioritize low latency over high throughput, %when we must choose between them
in the best case enabling analysts to manipulate Accumulo data interactively.
% explain why performance is whole-table

%\subsection{Paper Outline}

We review iterator stacks, Accumulo's model of server-side computation, in Section 2.
Section 3 formally defines matrix multiplication and compares inner and outer product formulations,
ultimately settling on outer product for our TableMult implementation.
We show TableMult's design as Accumulo iterators in Section 4,
and we test its scalability with experiments in Section 5.

%Background and Algorithms
%Primer


%\section{Background}
%\label{sBackground}







\section{Accumulo Server-side Computation: Iterators}
Accumulo includes a mechanism to perform limited serer-side computation called the 
\emph{iterator stack}.  Iterators inside the iterator stack are objects of classes
that implement the \texttt{SortedKeyValueIterator} (SKVI) interface, an interface
reminiscent of but more complex than built-in Java iterators %from the \texttt{java.lang} package
in that they have methods to return a current entry (\texttt{getTopKey} and \texttt{getTopValue})
and proceed to the next entry (\texttt{next}) until no more entries remain (\texttt{hasTop}).
Iterators may hold state initialized in \texttt{init}, to which Accumulo hands 
options of the form \texttt{Map<String,String>} passed from the client.%, though the state should 
%be arranged in such a way as to

Arguably, the most critical component of an iterator is its \texttt{seek} method,
which instructs an iterator to jump to the beginning of a passed-in range. System iterators 
at the top of an iterator stack perform actual disk seeks.% and cache locations in memory when seeked.

During a scan, Accumulo constructs an iterator stack for each tablet whose keys overlap some portion 
of the scan range. These iterator stacks may run in parallel, and each is seeked to the range of 
keys in the current tablet, instersected with the scan range. When any call to the iterator stack 
returns, Accumulo may choose to destroy the iterator stack and later re-create it,
passing a new seek range starting at the last key returned from \texttt{getTopKey}, exclusive.
Accumulo does this when it needs to switch data sources (such as RFiles) after a compaction, 
when a client stops requesting data, or out of fairness to other concurrent scans.

Iterators do not have full lifecycle control in that there is no \texttt{close} method 
that allows an iterator to clean up its state before being destroyted. The only safe way for an 
iterator to use state requiring cleanup, such as opening a file or starting a thread,
is for the iterator to clean up its state before returning from a method call.
Ideas discussed in \cite{ACCUMULO-3751} may lax this restriction for future Accumulo versions.

%\1 Iterators are most commonly used for streaming computation in the sense that iterators
%should ideally run in a single pass over their source's data and not store too much state.
%\1 No lifecycle control.

